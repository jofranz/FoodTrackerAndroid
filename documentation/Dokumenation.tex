\documentclass[
    DIV12,
    cleardouble=plain,
    headings=normal,
    pdftex,
    headexclude,footexclude,
    final
]{scrreprt}


\usepackage[dvipsnames]{xcolor} % for kotlin	
%\usepackage{spreadtab}
\usepackage{xspace}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage[pdftex]{graphicx}
\usepackage[bookmarks]{hyperref}
\usepackage{scrpage2}
\usepackage{longtable}
\usepackage{caption}
\usepackage{pgfplots}
\usepackage{float}
%\usepackage{xcolor}
\usepackage{colortbl}
\usepackage{tabularx}
\usepackage{multirow} % tabelle
\usepackage{listings} % code aus datei einbinden
\usepackage{scrhack}
\usepackage{comment}




% word wrap with a red arrow
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}

\graphicspath{{./}{./images/}}


% kotlin syntax highlighting
\lstdefinelanguage{Kotlin}{
  keywords={package, as, typealias, this, super, val, var, fun, for, null, true, false, is, in, throw, return, break, continue, object, if, try, else, while, do, when, yield, typeof, yield, typeof, class, interface, enum, object, override, public, private, get, set, import, abstract, },
  keywordstyle=\color{NavyBlue}\bfseries,
  ndkeywords={@Deprecated, Iterable, Int, Integer, Float, Double, String, Runnable, dynamic},
  ndkeywordstyle=\color{BurntOrange}\bfseries,
  emph={println, return@, forEach,},
  emphstyle={\color{OrangeRed}},
  identifierstyle=\color{black},
  sensitive=true,
  commentstyle=\color{gray}\ttfamily,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  stringstyle=\color{ForestGreen}\ttfamily,
  morestring=[b]",
  morestring=[s]{"""*}{*"""},
}



% word wrap with a red arrow
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}

% #################################################################

\hyphenation{Cha-otn-gsch-werl}
\setlength\headheight{1.75cm}


\ihead{\small{Android Food Tracking App in Kotlin}}
\chead{}
\ohead{\includegraphics[height=0.05\textheight]{fh_logo}}
\ifoot{\small{Smartphone Programming III}}
\ofoot{\small{Johannes Franz \& Normen Krug}}
\pagestyle{scrheadings}









\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\renewcommand{\arraystretch}{1}

\parskip0.5\baselineskip plus 0.125\baselineskip minus 0.25\baselineskip
\parindent0em

%\automark[section]{chapter}

\titlehead{\begin{center}\includegraphics[width=5cm]{fh_logo}\end{center}}
 \title{
  Entwicklung einer Android Food Tracking App \\[1em]
  in der Programmiersprache Kotlin  
}
\publishers{Vorgelegt bei Prof. Dr. Michael Stepping}

\author{Johannes Franz \& Normen Krug}


\date{Wintersemester 2017/2018}


\begin{document}
\maketitle


\pagenumbering{roman}

\tableofcontents

%\listoftables

\newpage
\pagenumbering{arabic}


\chapter{Einleitung}
Ziel ist es eine Open Source App zu entwickeln, die einen Rückschluss von sich zugenommener Nahrung auf Symptome zu ermöglichen. Dabei helfen die in der App eingetragenen Datenpunkte und Fotos diese z.B. mit einer allergischen Reaktion zu verknüpfen.
Zielgruppe sind Menschen, die wegen Erkrankungen aus ihren zu sich zugenommenen Speisen und Getränken Rückschlüsse auf ihr Wohlbefinden treffen wollen, um zukünftig solche Speisen zu meiden.


\chapter{Motivation}
Durch eigenen Bedarf motiviert entstand die Idee zu dieser App. Um aus wiederkehrenden Mahlzeiten eine Unverträglichkeit abzuleiten, stellt die App entsprechende Funktionen bereit.
Bei dieser Arbeit war außerdem das Ziel möglichst viele neue Technologien zu verwenden. So wurde bei allen Möglichkeiten der schwierigere Weg gewählt, der jedoch zu neuen Erkenntnissen führte.\\
Beispiele dafür sind:\\
Kotlin, LaTeX, In-App-SQLite,Dagger, Room, Recycler View, Model View Presenter, Spinner Menu in der Toolbar

\newpage

\chapter{Kotlin als Programmiersprache}
Für die App wurde die Programmiersprache Kotlin verwendet, welche auf der Google IO im Mai 2017 als offizielle Sprache für Android eingeführt wurde. Kotlin hat einen besser lesbaren Syntax als Java. Wie bei Java wird auch bei Kotlin der Bytecode für die Java Virtual Machine übersetzt. Insgesamt ist Kotlin der Programmiersprache Swift 3 bzw 4 syntaktisch sehr nahe, was den Umgang als Entwickler mobiler Anwendungen zusätzlich erleichtert. Die Entscheidung dieses Sprache zu wählen war wieder davon getrieben etwas neues auszuprobieren.\\

Kotlin Code Beispiel:
\lstinputlisting[language=Kotlin]{content/Kotlin_example.kt}

\newpage

\chapter{Entwurfsphase}
In der Entwurfsphase wurde keine Zeit verschwendet und somit wurde der Fokus auf Handskizzen gelegt. Der Zwischenschritt diese Skizzen in einem professionellen Entwurf nachzubauen sparte Zeit, so dass sich direkt mit der Programmierung beschäftigt werden konnte.



\section{Main Screen}
Der Main Screen hat während der Entwicklungsphase viele Veränderungen durchlaufen. So ist die TabBar von unten nach oben platziert worden. Die Datumsauswahl wurde durch eine sinnvollere Gruppierung ersetzt.
\begin{figure}[H]
	\centering
  \frame{ \includegraphics[scale=0.7]{main} }
	\caption{Main Screen}
	\label{main}
\end{figure}

\newpage
\section{Hinzufügen eines Eintrags}
Der \textit{Add Screen} hat sich während der Entwicklung nur wenig verändert und konnte daher so umgesetzt werden. Um es dem Nutzer einfach zu machen werden hier die aktuellen Werte übernommen.
Wichtige Felder lassen sich in einem \textit{Edit Screen} bearbeiten. Dieser wurde um einzelne Elemente erweitert, die beim Hinzufügen noch keine Rolle spielen. Beispiele dafür sind die \textit{SeekBar} und die \textit{Effekt Description}.
\begin{figure}[H]
	\centering
  \frame{ \includegraphics[scale=0.7]{add_entwurf} }
	\caption{Hinzufügen eines Eintrags}
	\label{add_entwurf}
\end{figure}

\newpage
\section{Popover im Main Screen}
Da Popover keinen guten Stil in der Benutzerführung darstellen,  wurden sie durch bessere UI Features ersetzt.
\begin{figure}[H]
	\centering
  \frame{ \includegraphics[scale=0.7]{popover} }
	\caption{Popover Screen}
	\label{popover}
\end{figure}


\section{Settings}
Da die Komplexität der App im Hintergrund abläuft und Settings oft verwirrend sind wurde diese Idee letztendlich verworfen. \\
Das Drei-Punkte-Menü stellt Funktionen bereit, die in den Settings sonst nicht so einfach auffindbar wären.
\begin{figure}[H]
	\centering
  \frame{ \includegraphics[scale=0.7]{settings} }
	\caption{Settings Screen}
	\label{settings}
\end{figure}


\section{Navigation Drawer Menü}
Der auch unter "Hamburger Menü" bekannte \textit{Navigation Drawer} war einer der ersten Ideen für die App. Viele Funktionen später als Tab Bar bzw. als Icons in der oberen rechten Ecke umgesetzt wurden, sind diese Buttons an die genannten Stellen hin verschoben worden. Im Sinne der Anwenderfreundlichkeit wurde sich am Ende gegen den Navigation Drawer entschieden.
\begin{figure}[H]
	\centering
  \frame{ \includegraphics[scale=0.7]{main_burger} }
	\caption{Navigation Drawer Menü Screen}
	\label{main_burger}
\end{figure}

\newpage

\section{Karten Screen}
Der Karten Screen zeigt eine Google Map. Darin repräsentieren Pins die Standorte an denen Essens Einträge hinzugefügt wurden.
\begin{figure}[H]
	\centering
  \frame{ \includegraphics[scale=0.7]{map} }
	\caption{Karten Screen}
	\label{map}
\end{figure}




\newpage



\chapter{Screendesign}
Dieses Kapitel zeigt die Umsetzung der Screens in der App. Von der Entwurfsphase wurde vereinzelt abgewichen, um dem Nutzer eine bessere Benutzererfahrung zu gewährleisten.

\newpage

\section{Main Screeen}
Der Main Screen zeigt verschiedene Elemente. Darunter ist eine Tab Bar, ein Spinner, Floating Action Button und eine Liste mit Einträgen.
\begin{figure}[H]
	\centering
  \frame{ \includegraphics[width=0.6\textwidth]{mainscreen} }
	\caption{Haupt Screen mit Einträgen}
	\label{mainscreen}
\end{figure}
\newpage


\section{Add Screen}
Beim Hinzufügen eines Eintrags stehen die \textit{EditText} Elemente \textit{Food Name} und \textit{Food Description} bereit. Die Adresse wird anhand der GPS Location automatisch generiert. Die Uhrzeit stellt die aktuelle Uhrzeit dar. Der \textit{Floating Action Buttion} ermöglicht das Aufrufen der Kamera. Der \textit{ADD ENTRY} Button fügt den Eintrag zur Liste hinzu.
\begin{figure}[H]
	\centering
  \frame{ \includegraphics[width=0.6\textwidth]{addScreen} }
	\caption{Hinzufügen eines Eintrags}
	\label{addScreen}
\end{figure}



\newpage



\section{Edit Screen}
Hier lassen sich die bereits zuvor vorhandenen Informationen bearbeiten. Die Beschreibung der Auswirkungen ermöglicht das optionale Hinterlassen einer Notiz wie es einem nach dem Essen ergangen ist.
\begin{figure}[H]
	\centering
  \frame{ \includegraphics[width=0.6\textwidth]{editScreen} }
	\caption{Bearbeiten eines Eintrags}
	\label{editScreen}
\end{figure}


\newpage

\section{Map Screen}
Der in der Entwurfsphase beschriebene Ansatz konnte fast identisch übernommen werden. Das \textit{Info Window} stellt eine Beschriftung bereit. Ein Klick auf diese Beschriftung führt zum Bearbeiten Screen.

\begin{figure}[H]
	\centering
  \frame{ \includegraphics[width=0.6\textwidth]{map_pin_detail} }
	\caption{Map mit Pin und Beschriftung}
	\label{Map mit Pin und Beschriftung}
\end{figure}



\chapter{Umsetzung}
Dieser Abschnitt beschreibt die technische Umsetzung der App. Dabei wird auf die einzelnen Schwerpunkte näher eingegangen.
\section{Datenbank}
	Für die Speicherung der Daten wurde sich für eine SQLite Datenbank entschieden. Das hat mehrere Vorteile. Zum einen lässt sich der Inhalt dieser Datenbank sehr einfach exportieren, um auf einem anderen Gerät wieder eingespielt werden zu können, zum anderen bietet eine Datenbankstruktur viele Möglichkeiten zur Datenanalyse mit schnellem Zugriff ohne wie bisher mit Files arbeiten zu müssen.

\subsection{Room}
Room wurde als Datenbank Abstraktionsschicht verwendet und bietet einfachen Datenbankzugriff. Die Room Bibliothek arbeitet mit Annotations. Mithilfe der Annotation und einer Hilfsklasse wird die Datenbank modeliert. 
\lstinputlisting[language=Kotlin]{content/Room_example.kt}
\newpage

Durch verschiede Annotations und einer Datenzugriffsklasse, werden "stored procedure" erstellt.
Diese haben den Vorteil das sie zu Compilezeit ausgewertet werden. Dadurch sind Fehler leichter aufspürbar und die Zugriffe werden optimiert.


\lstinputlisting[language=Kotlin]{content/Room_queries.kt}

Quelle:
\url{https://developer.android.com/topic/libraries/architecture/room.html}


\subsection{CSV Export}
Das Ausgabeformat CSV (Comma Separated Values) beschreibt den Aufbau einer Textdatei. Darin sind alle übergebenen Spaltennamen eingetragen. Die Reihenfolge der Spaltennamen gibt die Reihenfolge der Werte, die darunter aufgelistet sind wieder. Jeder Werteeintrag ist mit einem Return vom anderen getrennt.\\

\begin{figure}[H]
	\centering
  \frame{ \includegraphics[width=0.92\textwidth]{csv_button} }
	\caption{CSV Export Button}
	\label{csv_button}
\end{figure}

Die App unterstützt den .CSV Export. Der Export wird als "FoodtrackerData.csv" File im Download Ordner gespeichert.

\lstinputlisting[language=SQL]{content/export.csv}

Dieser Ordner ist auf jedem Android Gerät einsehbar und kann heruntergeladen werden.

\newpage

\section{Page Adapter}
Damit die App eine funktionierende Tabbar besitzt, muss ein PageAdapter erstellt werden. Dieser Adapter legt fest wie viel Tabs vorhanden sind, außerdem wird das Wechseln der Tabs gehandhabt. Bei einen Klick auf einem der Tabs wird die \textit{getItem} Methode aufgerufen. Diese erstellt das passende Fragment und gibt es der View zurück.\\

\lstinputlisting[language=Kotlin]{content/page_adapter.kt}


\section{Google Maps}
Für die Karte ist die Google Maps API eingesetzt worden. Darin wird für jeden Eintrag ein Pin in der Karte dargestellt.
Der API Key wurde dankenswerterweise von Normen bereitgestellt.
Die Google Map wird asynchron geladen. Nachdem sie vollständig geladen ist, werden die Koordinaten der einzelnen Speisen aus der Datenbank geladen. Die Markierung des Standortes geschieht mithilfe der Marker Klasse. Dieser Klasse werden außer den oben genannten Koordinaten noch der Title und die Beschreibung einer Speise übergeben. Beim Klick auf einen Marker (Pin) öffnet sich ein 
InfoWindow, welches die Informationen anzeigt. Auf diesen InfoWindow ist ein onClickListener registriert, welcher die ausgewählte Speise in der Detail Ansicht öffnet.


\newpage

\section{MVP}
MVP ist ein Entwurfsmuster in der Softwareentwicklung.  Dieses unterteilt die Applikation in drei Bestandteile: Model, View, Presenter.\\


\begin{figure}[H]
		\centering
	\frame{ \includegraphics[scale=1.0]{MVP} }
		\caption{Model view presenter}
	\label{MVP}
\end{figure}
	

Das Model hält die Daten die in der App verwendet werden. Sie strukturiert die Daten logisch. Der Presenter holt sich die Daten aus den Model und verarbeitet sie. Sie stellt die verarbeiten Daten bereit die die View anzeigt.

\newpage

\chapter{Herausforderungen}
In jedem Projekt treten bei ansteigender Komplexität Probleme auf. Diese sind in diesem Abschnitt vermerkt.

\begin{itemize}
\item Aufwändige Integration von Dagger 2 die letztendlich verworfen werden musste. Mangelnde Dokumentation. Probleme beim Integrieren von bereits vorhandenen Projekten.
\item Constraint Layouts bringen, wenn sie in einer NestedScrollView eingebunden sind gewisse Probleme. So liegt der zu bearbeitende Teil des Screens häufig außerhalb der Reichweite in der man diese bearbeiten kann.
\item Laut der Google Dokumentation sind Bitmaps das vorgeschlagene Dateiformat für den Umgang mit Bildern. Das hat das Problem, dass bei Verarbeitung mehrere Bilder große Mengen an Daten im Arbeitsspeicher liegen. Der Arbeitsspeicher des Gerätes wird dabei zum Flaschenhals. Bei einer Komprimierung wird dabei zwischen RAM- und CPU-Auslastung abgewogen.

\end{itemize}

\newpage

\chapter{Lessons learned}
Dem Parkinsonschen Gesetz folgend wurde die Features während der vorhandenen Zeit umgesetzt. Da während der Appentwicklung die Stundenplan App der Hochschule betreut wurde, entstand gelegentlich ein Interessen- und Ressourcenkonflikt. Letztendlich wurden die Änderungen an der Schnittstelle leicht gewichtet behandelt, da diese einen Mehrwert für viele Hundert Studenten auf Android und iOS Seite mit sich brachten.\\
Zu Beginn des Projektes ist es schwer die Architektur im größeren Stil planen. Da Features nach und nach erweitert wurden, ist es nötig geworden die Architektur anzupassen, was zu Mehrarbeit geführt hat.

\newpage

\chapter{Weitere Arbeiten}
In diesem Projektabschnitt konnten alle gesteckten Ziele erreicht werden. Da solch ein junges Projekt noch viele Möglichkeiten beinhaltet Funktionen zu verbessern und neue Funktionen einzuführen werden hier mögliche Punkte zur Anregung aufgelistet. 
Eine Erweiterung die sich um die Inhaltsstoffe der Mahlzeiten dreht und diese speziell auswertet, würde dem Nutzer zusätzliche Vorteile bieten. Diese Daten sind anonym genug um mittels Cloud Schnittstelle mit Werten anderer Personen verglichen werden kann.

Da das Projekt als Open Source Projekt auf GitHub zur Verfügung steht, sind forks und pull pull requests willkommen. Da das Projekt somit der Öffentlichkeit übergeben wurde, besteht durchaus ein Interesse unsererseits die App weiter zu entwickeln.


\newpage


\listoffigures

\end{document}